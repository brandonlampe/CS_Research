"""
Script written to solve for the transport properties of crushed salt.
    Properties are obtained by solving the inverse problem of diffusional
    flow through crushed salt (1D Heat Eqn).
"""
import numpy as np
import matplotlib.pyplot as plt
import sys
sys.path.append('/Users/Lampe/PyScripts/CS_Research')
import ResearchFunc as rf


# USER INPUT VALUES
LNTH = 10.0E-2  # [M] AXIAL LENGTH OF SAMPLE BEING TESTED
DIA = 9.0E-2  # [M] AVERAGE DIAMETER OF SAMPLE BEING TESTED
TSRT = 100  # [SEC] TIME OF INITIAL MEASUREMENT
TEND = 300  # [SEC] TIME OF FINAL MEASUREMENT
P_US = 8.2*(101325/14.6959)  # [PA] UPSTREAM PRESSURE
P_DS = 1.0*(101325/14.6959)  # [PA] DOWNSTREAM PRESSURE

# MATERIAL PROPERTIES
PERM = 1E-16  # [METER2]
VISC = 1.7798E-5  # [PA-S] AVERAGE VISCOSITY OF N2
CGAS = 1.0/142517.8  # [1/PA] GAS COMPRESSIBILITY - SHOULD UPDATE IN FUTURE
CRCK = 1.0/40E9  # [1/PA] CRUSHED SALT BULK COMPRESSIBILITY [BROOME, 2014]
PORO = 0.03  # [DIMLESS] ROCK POROSITY
AREA = np.pi*DIA**2/4.0  # [CM2] X-SECT AREA OF SAMPLE, ORTH. TO FLOW
STOR = PORO*CGAS + CRCK  # [1/PA] SPECIFIC STORAGE
COND = PERM/VISC  # [L2/PA-S] HYDRAULIC CONDUCTIVITY

# REFERENCE VALUES - USED TO NONDIMENSIONALIZE PARAMETERS
PERM_REF = 1E-18  # [METER2] REFERENCE PERMEABILITY
VISC_REF = 1.983E-5  # [PA-S] VISCOSITY OF AIR AT AMBIENT CONDITIONS
PRES_REF = P_US  # [PA] MAX DIFFERENTIAL PRESSURE
COND_REF = PERM_REF/VISC_REF  # [L2/PA-S] HYDRAULIC CONDUCTIVITY
LNTH_REF = LNTH  # [M] SAMPLE LENGTH
TIME_REF = (LNTH_REF**2 * STOR)/COND_REF
FORC_REF = COND_REF*PRES_REF/LNTH_REF**2

# CONSTANT DIMENSIONLESS PARAMETERS
LNTH_BAR = LNTH/LNTH_REF
COND_BAR = COND/COND_REF  # HYDRAULIC CONDUCTIVITY
AREA_BAR = AREA/LNTH_REF**2

# DISCRETIZATION OF INDEPENDENT VARIABLES
NEL = 30  # NUMBER OF SPATIAL INCREMENTS
TIME_INC = 10  # NUMBER OF TEMPORAL INCREMENTS

# SETUP SPATIAL NODES
NNODE = NEL + 1
NODE_ARR = np.linspace(0, LNTH, NNODE)
EL_SIZE = np.float(NODE_ARR[-1] - NODE_ARR[0])/NEL  # SIZE OF ELEMENT

# SETUP TEMPORAL NODES
TIME_DUR = TEND - TSRT  # DURATION OF ANALYSIS
TIME_ARR = np.linspace(0, TIME_DUR, TIME_INC + 1)
S_SIZE = np.float(TIME_ARR[-1] - TIME_ARR[0])/TIME_INC  # SIZE OF TIME STEP

# DIMENSIONLESS FORMS OF INDEPENDENT VARIABLES
NODE_BAR = NODE_ARR/LNTH_REF
TIME_BAR = TIME_ARR/TIME_REF

# BOUNDARY CONDTIONS (DIMENSIONLESS)
BCTYPE = [1, 1]  # 1 => essential, 0 => flux
BCUS_BAR = P_US/PRES_REF  # essential BCT at x=0, UPSTREAM
BCDS_BAR = P_DS/PRES_REF  # essential BCT at x=1, DOWNSTREAM

# INITIAL CONDITIONS (DIMENSIONLESS)
ICOND_BAR = np.ones(NNODE)*BCUS_BAR


# FORCING FUNCTION
def forc_func(x):
    """
    NEED TO BE AWARE OF DIMENSIONS OF FORCING FUNCTION
    """
    return x*0  # CHECK DIMENSIONS! forcing function F(x)

FORC_BAR = forc_func(NODE_BAR)/FORC_REF  # DIMENSIONLESS FORM

# INTEGRATION TYPE
ITYPE = 1  # fully implicit (DETERMINES THE INTEGRATION TYPE)

# DEFINE THE CLASS
SOLN = rf.HeatEqn_1D(NODE_BAR, TIME_BAR, ICOND_BAR, 1.0, COND_BAR, forc_func,
                     BCTYPE, BCUS_BAR, BCDS_BAR, AREA_BAR, ITYPE)
PRES_BAR = SOLN.solve()

# PLOT RESULTS
FIG_I, AX1 = plt.subplots(figsize=(12, 8))

LBL = [None]*len(TIME_ARR)
for i in xrange(len(TIME_ARR)):
    LBL[i] = 'time = {:.3g} s'.format(TIME_ARR[i])  # + str(TIME_ARR[i])

# when plotting from arrays, columns from each are plotted against eachother
AX1.plot(NODE_BAR, PRES_BAR.T, 'o-', lw=1)
AX1.legend(LBL, frameon=1, framealpha=1, loc=0)

AX1.set_xlabel('Dimensionless Length', fontsize=12)
AX1.set_ylabel('Dimensionless Pressure', fontsize=12)
AX1.set_title(''r'One-Dimensional Transient Analysis', fontsize=16)
AX1.grid(b=True, which='major')
AX1.grid(b=True, which='major')
plt.show()
